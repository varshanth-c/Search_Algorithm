<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Maze Solver Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f0f2f5;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 15px;
        }
        
        .description {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        @media (min-width: 992px) {
            .container {
                flex-direction: row;
            }
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        
        .controls {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-section {
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 6px;
            background-color: #fafafa;
        }
        
        .control-section h3 {
            margin-bottom: 12px;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 100px;
        }
        
        button:hover {
            background-color: #365987;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        button.primary {
            background-color: #28a745;
        }
        
        button.primary:hover {
            background-color: #218838;
        }
        
        button.secondary {
            background-color: #6c757d;
        }
        
        button.secondary:hover {
            background-color: #5a6268;
        }
        
        button.danger {
            background-color: #dc3545;
        }
        
        button.danger:hover {
            background-color: #c82333;
        }
        
        select, input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            margin-bottom: 10px;
        }
        
        input[type="range"] {
            margin-top: 5px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
        }
        
        .flex-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            border-radius: 6px;
            background-color: #f8f9fa;
            border-left: 4px solid #4a6fa5;
        }
        
        .info-panel h3 {
            margin-bottom: 10px;
            color: #444;
        }
        
        .info-panel p {
            color: #666;
            line-height: 1.5;
        }
        
        .settings-section {
            margin-top: 15px;
        }
        
        .statistics {
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .statistics p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #666;
        }
        
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #f0f2f5; /* Default light theme background for the button itself */
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem; /* For emoji icon */
            z-index: 1000; /* Ensure it's on top */
            color: #333; /* Default light theme icon color */
        }
        
        .dark-theme {
            background-color: #121212;
            color: #e0e0e0;
        }
        
        .dark-theme .canvas-container,
        .dark-theme .controls {
            background-color: #1e1e1e;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            border-color: #333; /* Add border color for dark theme containers */
        }

        .dark-theme .control-section {
            background-color: #2d2d2d;
            border-color: #333;
        }
        
        .dark-theme canvas {
            border-color: #444;
            background-color: #2c2c2c; /* Darker background for canvas itself */
        }
        
        .dark-theme h1,
        .dark-theme h3,
        .dark-theme .control-section h3 /* Target specific h3 */ {
            color: #e0e0e0;
        }
        
        .dark-theme .description,
        .dark-theme label,
        .dark-theme p,
        .dark-theme .statistics p, /* Target specific p */
        .dark-theme .legend-item span /* Target legend text */ {
            color: #b0b0b0;
        }
        
        .dark-theme .info-panel {
            background-color: #2d2d2d;
            border-left-color: #6d8cb5;
        }
        
        .dark-theme .info-panel h3 {
            color: #e0e0e0;
        }
        
        .dark-theme .info-panel p {
            color: #b0b0b0;
        }
        
        .dark-theme .statistics {
            background-color: #2d2d2d;
        }
        
        .dark-theme select,
        .dark-theme input:not([type="range"]), /* Don't style range inputs too heavily */
        .dark-theme input[type="text"] /* Example if you add text inputs */ {
            background-color: #333;
            border-color: #555;
            color: #e0e0e0;
        }
        .dark-theme input::placeholder { /* For placeholder text in dark mode */
            color: #888;
        }

        .dark-theme .theme-toggle {
            background-color: #2d2d2d; /* Dark theme background for the button */
            border-color: #555;
            color: #e0e0e0; /* Dark theme icon color */
        }
        
        .flash {
            animation: flash-animation 0.5s;
        }
        
        @keyframes flash-animation {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .algorithm-info {
            margin-top: 15px;
            display: none;
        }
        
        .algorithm-info.active {
            display: block;
        }
        
        .help-icon {
            font-size: 14px;
            background-color: #6c757d;
            color: white;
            width: 18px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            margin-left: 5px;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="themeToggle" class="theme-toggle" title="Toggle Theme">🌙</div>
    <h1>Maze Solver Visualizer</h1>
    <p class="description">Generate random mazes and visualize different graph traversal algorithms solving them in real-time.</p>
    
    <div class="container">
        <div class="canvas-container">
            <canvas id="mazeCanvas" width="500" height="500"></canvas>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #00cc00;"></div> <!-- Updated to match JS -->
                    <span>Start</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff0000;"></div> <!-- Updated to match JS -->
                    <span>End</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #000000;"></div> <!-- Updated to match JS -->
                    <span>Wall</span>
                </div>
                 <div class="legend-item">
                    <div class="legend-color" style="background-color: #ffffff; border: 1px solid #ccc;"></div> <!-- For Empty -->
                    <span>Path/Empty</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #a0d2eb;"></div>
                    <span>Visited</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ffcc66;"></div>
                    <span>Solution Path</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff9999;"></div>
                    <span>Frontier</span>
                </div>
            </div>
            
            <div class="statistics">
                <p id="cellsVisited">Cells Visited: 0</p>
                <p id="pathLength">Path Length: 0</p>
                <p id="executionTime">Execution Time: 0 ms</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>Maze Configuration</h3>
                <div class="form-group">
                    <label for="mazeSizeX">Width: <span id="mazeSizeXValue">10</span></label>
                    <input type="range" id="mazeSizeX" min="5" max="40" value="10">
                </div>
                <div class="form-group">
                    <label for="mazeSizeY">Height: <span id="mazeSizeYValue">10</span></label>
                    <input type="range" id="mazeSizeY" min="5" max="40" value="10">
                </div>
                <div class="form-group">
                    <label for="mazeComplexity">Maze "Wall Density" (Lower = Sparser): <span id="mazeComplexityValue">0.75</span></label>
                    <input type="range" id="mazeComplexity" min="0.1" max="0.95" step="0.05" value="0.75">
                </div>
                <div class="btn-group">
                    <button id="generateMazeBtn" class="primary">Generate Maze</button>
                    <button id="clearMazeBtn">Clear Path</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Algorithm Controls</h3>
                <div class="form-group">
                    <label for="algorithmSelect">Algorithm</label>
                    <select id="algorithmSelect">
                        <option value="bfs">Breadth-First Search (BFS)</option>
                        <option value="dfs">Depth-First Search (DFS)</option>
                        <option value="astar">A* Search</option>
                        <option value="dijkstra">Dijkstra's Algorithm</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="animationSpeed">Animation Speed: <span id="animationSpeedValue">50</span>ms</label>
                    <input type="range" id="animationSpeed" min="10" max="500" step="10" value="50">
                </div>
                <div class="btn-group">
                    <button id="startAlgorithmBtn" class="primary">Start</button>
                    <button id="pauseResumeBtn" disabled>Pause</button>
                    <button id="stepBtn" disabled>Step</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Edit Maze <span class="tooltip help-icon">?<span class="tooltip-text">Click to use selected Edit Mode. Alternatively: Shift+Click for Start, Ctrl+Click for End, Alt+Click to toggle Wall.</span></span></h3>
                <div class="form-group">
                    <label for="editMode">Edit Mode (for simple click)</label>
                    <select id="editMode">
                        <option value="wall">Toggle Wall</option>
                        <option value="start">Set Start</option>
                        <option value="end">Set End</option>
                    </select>
                </div>
                <button id="loadSavedMazeBtn">Load Saved Maze</button>
                <button id="saveMazeBtn">Save Current Maze</button>
            </div>
            
            <div class="info-panel">
                <h3>Algorithm Information</h3>
                <div id="algorithmInfoContainer"> <!-- Changed ID for clarity -->
                    <div class="algorithm-info active" data-algorithm="bfs">
                        <p><strong>Breadth-First Search (BFS)</strong> explores all neighbor nodes at the present depth level before moving to nodes at the next depth level. It's guaranteed to find the shortest path in an unweighted graph.</p>
                        <p>Time Complexity: O(V + E) where V is vertices and E is edges.</p>
                    </div>
                    <div class="algorithm-info" data-algorithm="dfs">
                        <p><strong>Depth-First Search (DFS)</strong> explores as far as possible along each branch before backtracking. It's not guaranteed to find the shortest path but uses less memory than BFS in some cases.</p>
                        <p>Time Complexity: O(V + E) where V is vertices and E is edges.</p>
                    </div>
                    <div class="algorithm-info" data-algorithm="astar">
                        <p><strong>A* Search</strong> combines aspects of uniform-cost search and pure heuristic search to efficiently compute optimal paths. It uses a heuristic function (Manhattan distance here) that estimates the cost from the current node to the goal.</p>
                        <p>Time Complexity: O(E log V) or O(E) with a good priority queue / heuristic. Worst case can be O(b^d).</p>
                    </div>
                    <div class="algorithm-info" data-algorithm="dijkstra">
                        <p><strong>Dijkstra's Algorithm</strong> finds the shortest path from a starting node to all other nodes in a weighted graph. When all weights are equal (as in this maze, cost=1 per step), it behaves like BFS.</p>
                        <p>Time Complexity: O(E log V) with a priority queue, or O(V² + E) with an adjacency matrix/simple array scan.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants for cell types
        const EMPTY = 0;
        const WALL = 1;
        const START = 2;
        const END = 3;
        const VISITED = 4;
        const PATH = 5;
        const FRONTIER = 6; // Cells currently in the open set/queue

        // Main maze class
        class MazeSolver {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.width = parseInt(document.getElementById('mazeSizeX').value);
                this.height = parseInt(document.getElementById('mazeSizeY').value);
                this.cellSize = 0; // Will be calculated
                this.maze = [];
                // Start and End cells are objects {x, y}
                this.startCell = { x: 0, y: 0 }; 
                this.endCell = { x: this.width - 1, y: this.height - 1 };
                
                this.isRunning = false;
                this.isPaused = false;
                this.animationSpeed = parseInt(document.getElementById('animationSpeed').value);
                this.algorithm = document.getElementById('algorithmSelect').value;
                this.complexity = parseFloat(document.getElementById('mazeComplexity').value); // "Wall density"
                
                this.visitedCells = 0;
                this.pathLength = 0;
                this.executionTime = 0;
                
                this.animationQueue = [];
                this.animationTimer = null;

                // Bind event listeners
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
                document.getElementById('generateMazeBtn').addEventListener('click', this.generateMaze.bind(this));
                document.getElementById('clearMazeBtn').addEventListener('click', this.clearAlgorithmTrace.bind(this)); // Renamed for clarity
                document.getElementById('startAlgorithmBtn').addEventListener('click', this.startAlgorithm.bind(this));
                document.getElementById('pauseResumeBtn').addEventListener('click', this.pauseResumeAlgorithm.bind(this));
                document.getElementById('stepBtn').addEventListener('click', this.stepAlgorithm.bind(this));
                document.getElementById('loadSavedMazeBtn').addEventListener('click', this.loadSavedMaze.bind(this));
                document.getElementById('saveMazeBtn').addEventListener('click', this.saveMaze.bind(this));
                
                document.getElementById('algorithmSelect').addEventListener('change', (e) => {
                    this.algorithm = e.target.value;
                    this.updateAlgorithmInfo();
                });
                document.getElementById('mazeSizeX').addEventListener('input', this.updateMazeSizeX.bind(this));
                document.getElementById('mazeSizeY').addEventListener('input', this.updateMazeSizeY.bind(this));
                document.getElementById('mazeComplexity').addEventListener('input', this.updateMazeComplexity.bind(this));
                document.getElementById('animationSpeed').addEventListener('input', this.updateAnimationSpeed.bind(this));
                document.getElementById('themeToggle').addEventListener('click', this.toggleTheme.bind(this));

                this.initialize();
            }

            initialize() {
                this.calculateCellSize();
                this.createEmptyMaze(); // This will set initial start/end
                this.draw();
                this.updateStatistics();
                this.updateAlgorithmInfo(); // Show info for default selected algorithm
                // Check for saved theme preference
                if (localStorage.getItem('mazeTheme') === 'dark') {
                    document.body.classList.add('dark-theme');
                    document.getElementById('themeToggle').textContent = '☀️';
                }
            }

            calculateCellSize() {
                const maxCellWidth = Math.floor(this.canvas.width / this.width);
                const maxCellHeight = Math.floor(this.canvas.height / this.height);
                this.cellSize = Math.min(maxCellWidth, maxCellHeight);
                if (this.cellSize < 5) this.cellSize = 5; // Minimum cell size
            }

            createEmptyMaze() {
                this.maze = Array(this.height).fill(null).map(() => Array(this.width).fill(EMPTY));
                
                // Ensure start and end are within new bounds
                this.startCell = { x: 0, y: 0 };
                this.endCell = { x: Math.max(0, this.width - 1), y: Math.max(0, this.height - 1) };

                // Avoid placing start and end on the same cell if maze is 1x1 or similar small
                if (this.width === 1 && this.height === 1) {
                    this.endCell = {x:0, y:0}; // Both on the same cell
                } else if (this.startCell.x === this.endCell.x && this.startCell.y === this.endCell.y) {
                     // If still same after default, move end if possible
                    if(this.width > 1) this.endCell.x = this.width -1;
                    else if (this.height > 1) this.endCell.y = this.height -1;
                }


                this.maze[this.startCell.y][this.startCell.x] = START;
                if(this.maze[this.endCell.y] !== undefined) { // Check if row exists
                    this.maze[this.endCell.y][this.endCell.x] = END;
                } else { // Fallback if dimensions are too small
                    this.endCell = {x: this.startCell.x, y: this.startCell.y};
                    this.maze[this.endCell.y][this.endCell.x] = END;
                }

            }

            generateMaze() {
                this.stopAlgorithm();
                this.calculateCellSize(); // Recalculate in case dimensions changed by other means
                
                // Initialize maze with all walls
                this.maze = Array(this.height).fill(null).map(() => Array(this.width).fill(WALL));
                
                const stack = [];
                // Start carving from a random odd position or (0,0) if preferred.
                // For simplicity and to ensure it's path, let's start from startCell
                let currentX = this.startCell.x;
                let currentY = this.startCell.y;
                this.maze[currentY][currentX] = EMPTY;
                stack.push({ x: currentX, y: currentY });

                const visitedForGen = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
                visitedForGen[currentY][currentX] = true;

                const directions = [
                    { x: 0, y: -2, wallY: -1 }, // North
                    { x: 2, y: 0, wallX: 1 },  // East
                    { x: 0, y: 2, wallY: 1 },  // South
                    { x: -2, y: 0, wallX: -1 }  // West
                ];
                
                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const unvisitedNeighbors = [];
                    
                    // Shuffle directions for randomness
                    directions.sort(() => Math.random() - 0.5);

                    for (const dir of directions) {
                        const nx = current.x + dir.x;
                        const ny = current.y + dir.y;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !visitedForGen[ny][nx]) {
                            unvisitedNeighbors.push({ nx, ny, dir });
                        }
                    }
                    
                    if (unvisitedNeighbors.length > 0) {
                        const { nx, ny, dir } = unvisitedNeighbors[0]; // Pick the first (shuffled)
                        
                        const wallX = current.x + (dir.wallX || 0);
                        const wallY = current.y + (dir.wallY || 0);
                        
                        this.maze[wallY][wallX] = EMPTY;
                        this.maze[ny][nx] = EMPTY;
                        visitedForGen[ny][nx] = true;
                        stack.push({ x: nx, y: ny });
                    } else {
                        stack.pop();
                    }
                }
                
                // Post-processing based on complexity (Wall Density)
                // Lower complexity = more paths (removes walls)
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        // Don't modify start/end cells during this random opening phase
                        if ((x === this.startCell.x && y === this.startCell.y) || (x === this.endCell.x && y === this.endCell.y)) {
                            continue;
                        }
                        if (this.maze[y][x] === WALL && Math.random() > this.complexity) {
                            this.maze[y][x] = EMPTY;
                        }
                    }
                }

                // Ensure start and end are not overwritten as WALL and are accessible
                this.maze[this.startCell.y][this.startCell.x] = START;
                this.maze[this.endCell.y][this.endCell.x] = END;
                
                // Optional: A more robust ensurePathExists could be added here if generation is imperfect
                // this.ensurePathExists(); // This was a bit too aggressive, standard backtracker should be fine.

                this.draw();
                this.visitedCells = 0;
                this.pathLength = 0;
                this.executionTime = 0;
                this.updateStatistics();
                this.flash(document.getElementById('generateMazeBtn'));
            }
            
            // ensurePathExists was sometimes too aggressive; a good generator shouldn't strictly need it.
            // If issues persist with unsolvable mazes, it can be reinstated and refined.

            clearAlgorithmTrace() {
                this.stopAlgorithm();
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.maze[y][x] === VISITED || this.maze[y][x] === PATH || this.maze[y][x] === FRONTIER) {
                            this.maze[y][x] = EMPTY;
                        }
                    }
                }
                this.visitedCells = 0;
                this.pathLength = 0;
                this.executionTime = 0;
                this.updateStatistics();
                this.draw();
                this.flash(document.getElementById('clearMazeBtn'));
            }

            startAlgorithm() {
                if (this.isRunning) return;
                
                this.clearAlgorithmTrace(); // Clear previous path/visited visuals
                
                document.getElementById('startAlgorithmBtn').disabled = true;
                document.getElementById('pauseResumeBtn').disabled = false;
                document.getElementById('stepBtn').disabled = false;
                document.getElementById('pauseResumeBtn').textContent = 'Pause';
                
                this.isRunning = true;
                this.isPaused = false;
                this.flash(document.getElementById('startAlgorithmBtn'));
                this.algorithm = document.getElementById('algorithmSelect').value; // Ensure current selection
                
                const startTime = performance.now();
                
                this.animationQueue = []; // Clear any old queue
                this.visitedCells = 0;
                this.pathLength = 0;

                switch (this.algorithm) {
                    case 'bfs': this.runBFS(); break;
                    case 'dfs': this.runDFS(); break;
                    case 'astar': this.runAStar(); break;
                    case 'dijkstra': this.runDijkstra(); break;
                }
                
                this.executionTime = Math.round(performance.now() - startTime);
                // Statistics are updated during/after animation for pathLength and visitedCells usually
                this.updateStatistics(); // Update time immediately
                
                this.startAnimation();
            }

            runBFS() {
                const queue = [{ x: this.startCell.x, y: this.startCell.y, path: [] }];
                const visited = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
                
                visited[this.startCell.y][this.startCell.x] = true;
                this.animationQueue.push({ type: 'frontier', x: this.startCell.x, y: this.startCell.y });
                
                const directions = [{ x: 0, y: -1 },{ x: 1, y: 0 },{ x: 0, y: 1 },{ x: -1, y: 0 }];
                let found = false;
                
                while (queue.length > 0 && !found) {
                    const current = queue.shift();
                    this.animationQueue.push({ type: 'visit', x: current.x, y: current.y });
                    this.visitedCells++;

                    if (current.x === this.endCell.x && current.y === this.endCell.y) {
                        found = true;
                        const path = [...current.path, { x: current.x, y: current.y }];
                        this.pathLength = path.length -1; // Exclude start
                        path.forEach(cell => this.animationQueue.push({ type: 'path', x: cell.x, y: cell.y }));
                        break;
                    }
                    
                    for (const dir of directions) {
                        const nx = current.x + dir.x;
                        const ny = current.y + dir.y;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && 
                            !visited[ny][nx] && this.maze[ny][nx] !== WALL) {
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny, path: [...current.path, { x: current.x, y: current.y }] });
                            if (this.maze[ny][nx] !== END) { // Don't mark end as frontier
                               this.animationQueue.push({ type: 'frontier', x: nx, y: ny });
                            }
                        }
                    }
                }
                if (!found) this.animationQueue.push({ type: 'no-path' });
            }
            
            runDFS() {
                const stack = [{ x: this.startCell.x, y: this.startCell.y, path: [] }];
                const visited = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
                
                // For DFS, we mark visited when pushing to stack to avoid cycles with multiple paths
                // but animation will show 'visit' when popped.
                // Or, mark visited when popped, and check before pushing if it's already on stack (more complex).
                // Simpler: mark visited when popped for animation.

                const directions = [{ x: 0, y: -1 },{ x: 1, y: 0 },{ x: 0, y: 1 },{ x: -1, y: 0 }];
                let found = false;

                while (stack.length > 0 && !found) {
                    const current = stack.pop();

                    if (visited[current.y][current.x]) continue; // Already processed this path
                    visited[current.y][current.x] = true;

                    this.animationQueue.push({ type: 'visit', x: current.x, y: current.y });
                    this.visitedCells++;

                    if (current.x === this.endCell.x && current.y === this.endCell.y) {
                        found = true;
                        const path = [...current.path, { x: current.x, y: current.y }];
                        this.pathLength = path.length - 1;
                        path.forEach(cell => this.animationQueue.push({ type: 'path', x: cell.x, y: cell.y }));
                        break;
                    }
                    
                    // Shuffle directions for typical DFS behavior
                    directions.sort(() => Math.random() - 0.5);

                    for (const dir of directions) {
                        const nx = current.x + dir.x;
                        const ny = current.y + dir.y;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && 
                            !visited[ny][nx] && this.maze[ny][nx] !== WALL) {
                            // Don't mark visited here, mark when popped. Stack handles not re-adding same path segment.
                            stack.push({ x: nx, y: ny, path: [...current.path, { x: current.x, y: current.y }] });
                             if (this.maze[ny][nx] !== END) {
                               this.animationQueue.push({ type: 'frontier', x: nx, y: ny });
                            }
                        }
                    }
                }
                if (!found) this.animationQueue.push({ type: 'no-path' });
            }
            
            runAStar() {
                const openSet = [{
                    x: this.startCell.x, y: this.startCell.y,
                    g: 0, h: this.heuristic(this.startCell.x, this.startCell.y, this.endCell.x, this.endCell.y),
                    f: 0, path: []
                }];
                openSet[0].f = openSet[0].h; // f = g + h, g is 0 for start

                const closedSet = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
                const gScores = Array(this.height).fill(null).map(() => Array(this.width).fill(Infinity));
                gScores[this.startCell.y][this.startCell.x] = 0;

                this.animationQueue.push({ type: 'frontier', x: this.startCell.x, y: this.startCell.y });
                const directions = [{ x: 0, y: -1 },{ x: 1, y: 0 },{ x: 0, y: 1 },{ x: -1, y: 0 }];
                let found = false;

                while (openSet.length > 0 && !found) {
                    openSet.sort((a, b) => a.f - b.f); // Sort by f-score to simulate priority queue
                    const current = openSet.shift();

                    if (closedSet[current.y][current.x]) continue;
                    closedSet[current.y][current.x] = true;
                    
                    this.animationQueue.push({ type: 'visit', x: current.x, y: current.y });
                    this.visitedCells++;

                    if (current.x === this.endCell.x && current.y === this.endCell.y) {
                        found = true;
                        const path = [...current.path, { x: current.x, y: current.y }];
                        this.pathLength = path.length-1;
                        path.forEach(cell => this.animationQueue.push({ type: 'path', x: cell.x, y: cell.y }));
                        break;
                    }

                    for (const dir of directions) {
                        const nx = current.x + dir.x;
                        const ny = current.y + dir.y;

                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && 
                            this.maze[ny][nx] !== WALL && !closedSet[ny][nx]) {
                            
                            const tentativeGScore = current.g + 1; // Cost is 1 per step

                            if (tentativeGScore < gScores[ny][nx]) {
                                gScores[ny][nx] = tentativeGScore;
                                const hScore = this.heuristic(nx, ny, this.endCell.x, this.endCell.y);
                                const fScore = tentativeGScore + hScore;
                                
                                // Add to open set (or update if already there, simple array push is fine if we check closedSet)
                                openSet.push({
                                    x: nx, y: ny,
                                    g: tentativeGScore, h: hScore, f: fScore,
                                    path: [...current.path, { x: current.x, y: current.y }]
                                });
                                 if (this.maze[ny][nx] !== END) {
                                   this.animationQueue.push({ type: 'frontier', x: nx, y: ny });
                                }
                            }
                        }
                    }
                }
                if (!found) this.animationQueue.push({ type: 'no-path' });
            }
            
            runDijkstra() { // Similar to A* with h=0
                const openSet = [{
                    x: this.startCell.x, y: this.startCell.y,
                    distance: 0, path: [] // distance is 'g' score
                }];
                const distances = Array(this.height).fill(null).map(() => Array(this.width).fill(Infinity));
                distances[this.startCell.y][this.startCell.x] = 0;
                const visited = Array(this.height).fill(null).map(() => Array(this.width).fill(false));

                this.animationQueue.push({ type: 'frontier', x: this.startCell.x, y: this.startCell.y });
                const directions = [{ x: 0, y: -1 },{ x: 1, y: 0 },{ x: 0, y: 1 },{ x: -1, y: 0 }];
                let found = false;

                while (openSet.length > 0 && !found) {
                    openSet.sort((a, b) => a.distance - b.distance); // Priority queue by distance
                    const current = openSet.shift();

                    if (visited[current.y][current.x]) continue;
                    visited[current.y][current.x] = true;

                    this.animationQueue.push({ type: 'visit', x: current.x, y: current.y });
                    this.visitedCells++;

                    if (current.x === this.endCell.x && current.y === this.endCell.y) {
                        found = true;
                        const path = [...current.path, { x: current.x, y: current.y }];
                        this.pathLength = path.length - 1;
                        path.forEach(cell => this.animationQueue.push({ type: 'path', x: cell.x, y: cell.y }));
                        break;
                    }

                    for (const dir of directions) {
                        const nx = current.x + dir.x;
                        const ny = current.y + dir.y;

                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height &&
                            this.maze[ny][nx] !== WALL && !visited[ny][nx]) {
                            
                            const newDistance = current.distance + 1;
                            if (newDistance < distances[ny][nx]) {
                                distances[ny][nx] = newDistance;
                                openSet.push({
                                    x: nx, y: ny,
                                    distance: newDistance,
                                    path: [...current.path, { x: current.x, y: current.y }]
                                });
                                 if (this.maze[ny][nx] !== END) {
                                   this.animationQueue.push({ type: 'frontier', x: nx, y: ny });
                                }
                            }
                        }
                    }
                }
                if (!found) this.animationQueue.push({ type: 'no-path' });
            }
            
            heuristic(x1, y1, x2, y2) {
                return Math.abs(x1 - x2) + Math.abs(y1 - y2); // Manhattan distance
            }

            stepAlgorithm() {
                if (!this.isRunning || this.animationQueue.length === 0) {
                    if (this.isRunning) this.stopAlgorithm(); // Auto-stop if queue empty
                    return;
                }
                
                const step = this.animationQueue.shift();
                const originalCellType = this.maze[step.y][step.x];
                
                // Avoid overwriting START/END cells visually unless it's the final path step on them.
                let canDraw = true;
                if ((originalCellType === START || originalCellType === END) && step.type !== 'path') {
                    canDraw = false;
                }


                switch (step.type) {
                    case 'visit':
                        if (canDraw) this.maze[step.y][step.x] = VISITED;
                        break;
                    case 'path':
                        // Path should always be drawn, even on start/end
                        if (originalCellType !== START && originalCellType !== END) {
                             this.maze[step.y][step.x] = PATH;
                        }
                        break;
                    case 'frontier':
                         if (canDraw && this.maze[step.y][step.x] !== VISITED) { // Don't draw frontier over already visited
                            this.maze[step.y][step.x] = FRONTIER;
                        }
                        break;
                    case 'no-path':
                        alert('No path found!');
                        this.stopAlgorithm();
                        break;
                }
                
                this.draw();
                this.updateStatistics(); // Update stats as algorithm progresses for visited count
                
                if (this.animationQueue.length === 0 && this.isRunning) { // Check isRunning, step might be called when paused
                    this.stopAlgorithm();
                }
                if (document.getElementById('stepBtn').disabled === false) { // Only flash if stepping manually
                    this.flash(document.getElementById('stepBtn'));
                }
            }

            pauseResumeAlgorithm() {
                if (!this.isRunning) return;
                this.isPaused = !this.isPaused;
                
                if (this.isPaused) {
                    document.getElementById('pauseResumeBtn').textContent = 'Resume';
                    clearInterval(this.animationTimer);
                } else {
                    document.getElementById('pauseResumeBtn').textContent = 'Pause';
                    this.startAnimation(); // Resume animation
                }
                this.flash(document.getElementById('pauseResumeBtn'));
            }

            startAnimation() {
                if (!this.isRunning || this.isPaused || this.animationQueue.length === 0) {
                     if (this.animationQueue.length === 0 && this.isRunning) this.stopAlgorithm();
                    return;
                }
                clearInterval(this.animationTimer); // Clear any existing timer
                this.animationTimer = setInterval(() => {
                    this.stepAlgorithm();
                }, this.animationSpeed);
            }

            stopAlgorithm() {
                clearInterval(this.animationTimer);
                this.isRunning = false;
                this.isPaused = false;
                // this.animationQueue = []; // Don't clear queue, user might want to step through remainder
                
                document.getElementById('startAlgorithmBtn').disabled = false;
                document.getElementById('pauseResumeBtn').disabled = true;
                document.getElementById('stepBtn').disabled = this.animationQueue.length === 0; // Disable step if queue is empty
                document.getElementById('pauseResumeBtn').textContent = 'Pause';
                this.updateStatistics(); // Final update
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const offsetX = (this.canvas.width - this.width * this.cellSize) / 2;
                const offsetY = (this.canvas.height - this.height * this.cellSize) / 2;
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const cellX = offsetX + x * this.cellSize;
                        const cellY = offsetY + y * this.cellSize;
                        let color;
                        switch (this.maze[y][x]) {
                            case EMPTY: color = document.body.classList.contains('dark-theme') ? '#44475a' : '#ffffff'; break;
                            case WALL: color = document.body.classList.contains('dark-theme') ? '#282a36' : '#000000'; break;
                            case START: color = '#00cc00'; break;
                            case END: color = '#ff0000'; break;
                            case VISITED: color = '#a0d2eb'; break;
                            case PATH: color = '#ffcc66'; break;
                            case FRONTIER: color = '#ff9999'; break;
                            default: color = document.body.classList.contains('dark-theme') ? '#44475a' : '#ffffff';
                        }
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
                        this.ctx.strokeStyle = document.body.classList.contains('dark-theme') ? '#6272a4' : '#cccccc';
                        this.ctx.strokeRect(cellX, cellY, this.cellSize, this.cellSize);
                        
                        if (this.maze[y][x] === START) {
                            this.ctx.fillStyle = document.body.classList.contains('dark-theme') ? '#f1fa8c' :'#004400';
                            this.ctx.font = `${this.cellSize * 0.6}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText('S', cellX + this.cellSize / 2, cellY + this.cellSize / 2 + 1); // +1 for better centering
                        } else if (this.maze[y][x] === END) {
                            this.ctx.fillStyle = document.body.classList.contains('dark-theme') ? '#f1fa8c' : '#440000';
                            this.ctx.font = `${this.cellSize * 0.6}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText('E', cellX + this.cellSize / 2, cellY + this.cellSize / 2 + 1);
                        }
                    }
                }
            }

            handleCanvasClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                const offsetX = (this.canvas.width - this.width * this.cellSize) / 2;
                const offsetY = (this.canvas.height - this.height * this.cellSize) / 2;
                const cellX = Math.floor((clickX - offsetX) / this.cellSize);
                const cellY = Math.floor((clickY - offsetY) / this.cellSize);
                
                if (cellX >= 0 && cellX < this.width && cellY >= 0 && cellY < this.height) {
                    if (this.isRunning) return;
                    
                    let currentEditMode = document.getElementById('editMode').value;
                    // Override with key modifiers
                    if (event.shiftKey) currentEditMode = 'start';
                    else if (event.ctrlKey || event.metaKey) currentEditMode = 'end'; // metaKey for Mac
                    else if (event.altKey) currentEditMode = 'wall';


                    const currentCellType = this.maze[cellY][cellX];

                    if (currentEditMode === 'wall') {
                        if (currentCellType === WALL) this.maze[cellY][cellX] = EMPTY;
                        else if (currentCellType === EMPTY) this.maze[cellY][cellX] = WALL;
                        // Don't change start/end by toggling wall
                    } else if (currentEditMode === 'start') {
                        if (currentCellType !== END && currentCellType !== WALL) { // Can't place start on wall or existing end
                            this.maze[this.startCell.y][this.startCell.x] = EMPTY; // Clear old start
                            this.startCell = { x: cellX, y: cellY };
                            this.maze[cellY][cellX] = START;
                        }
                    } else if (currentEditMode === 'end') {
                         if (currentCellType !== START && currentCellType !== WALL) { // Can't place end on wall or existing start
                            this.maze[this.endCell.y][this.endCell.x] = EMPTY; // Clear old end
                            this.endCell = { x: cellX, y: cellY };
                            this.maze[cellY][cellX] = END;
                        }
                    }
                    this.draw();
                }
            }

            saveMaze() {
                try {
                    const mazeData = {
                        width: this.width, height: this.height, maze: this.maze,
                        startCell: this.startCell, endCell: this.endCell,
                        complexity: this.complexity
                    };
                    localStorage.setItem('mazeSolverMaze', JSON.stringify(mazeData));
                    this.flash(document.getElementById('saveMazeBtn'));
                    alert('Maze saved!');
                } catch (e) { console.error("Error saving maze:", e); alert("Failed to save maze."); }
            }

            loadSavedMaze() {
                try {
                    const mazeDataString = localStorage.getItem('mazeSolverMaze');
                    if (!mazeDataString) { alert('No saved maze found.'); return; }
                    const parsedData = JSON.parse(mazeDataString);
                    
                    this.stopAlgorithm();
                    this.width = parsedData.width;
                    this.height = parsedData.height;
                    this.maze = parsedData.maze;
                    this.startCell = parsedData.startCell;
                    this.endCell = parsedData.endCell;
                    this.complexity = parsedData.complexity || 0.75;
                    
                    document.getElementById('mazeSizeX').value = this.width;
                    document.getElementById('mazeSizeXValue').textContent = this.width;
                    document.getElementById('mazeSizeY').value = this.height;
                    document.getElementById('mazeSizeYValue').textContent = this.height;
                    document.getElementById('mazeComplexity').value = this.complexity;
                    document.getElementById('mazeComplexityValue').textContent = this.complexity.toFixed(2);
                    
                    this.calculateCellSize();
                    this.clearAlgorithmTrace(); // Clears stats and path visuals
                    this.draw();
                    this.flash(document.getElementById('loadSavedMazeBtn'));
                } catch (e) { console.error("Error loading maze:", e); alert("Failed to load maze."); }
            }

            updateStatistics() {
                document.getElementById('cellsVisited').textContent = `Cells Visited: ${this.visitedCells}`;
                document.getElementById('pathLength').textContent = `Path Length: ${this.pathLength}`;
                document.getElementById('executionTime').textContent = `Execution Time: ${this.executionTime} ms`;
            }

            updateAlgorithmInfo() {
                const algorithm = document.getElementById('algorithmSelect').value;
                document.querySelectorAll('#algorithmInfoContainer .algorithm-info').forEach(div => {
                    div.classList.remove('active');
                });
                const selectedInfo = document.querySelector(`#algorithmInfoContainer .algorithm-info[data-algorithm="${algorithm}"]`);
                if (selectedInfo) selectedInfo.classList.add('active');
            }

            updateMazeSizeX() {
                const value = parseInt(document.getElementById('mazeSizeX').value);
                document.getElementById('mazeSizeXValue').textContent = value;
                if (this.width !== value) {
                    this.width = value;
                    this.stopAlgorithm();
                    this.calculateCellSize();
                    this.createEmptyMaze(); // This re-initializes start/end based on new width/height
                    this.draw();
                }
            }

            updateMazeSizeY() {
                const value = parseInt(document.getElementById('mazeSizeY').value);
                document.getElementById('mazeSizeYValue').textContent = value;
                if (this.height !== value) {
                    this.height = value;
                    this.stopAlgorithm();
                    this.calculateCellSize();
                    this.createEmptyMaze(); // This re-initializes start/end
                    this.draw();
                }
            }

            updateMazeComplexity() {
                const value = parseFloat(document.getElementById('mazeComplexity').value);
                document.getElementById('mazeComplexityValue').textContent = value.toFixed(2);
                this.complexity = value;
                // Optionally, auto-regenerate maze, or user can click generate
                // this.generateMaze(); 
            }

            updateAnimationSpeed() {
                const value = parseInt(document.getElementById('animationSpeed').value);
                document.getElementById('animationSpeedValue').textContent = `${value}ms`;
                this.animationSpeed = value;
                if (this.isRunning && !this.isPaused) { // If animation is active, restart with new speed
                    this.startAnimation();
                }
            }
            
            toggleTheme() {
                document.body.classList.toggle('dark-theme');
                const isDark = document.body.classList.contains('dark-theme');
                document.getElementById('themeToggle').textContent = isDark ? '☀️' : '🌙';
                localStorage.setItem('mazeTheme', isDark ? 'dark' : 'light');
                this.draw(); // Redraw maze with theme colors
                this.flash(document.getElementById('themeToggle'));
            }

            flash(element) {
                if (!element) return;
                element.classList.add('flash');
                setTimeout(() => element.classList.remove('flash'), 500);
            }
        }

        // Initialize the MazeSolver class after the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new MazeSolver('mazeCanvas');
        });
    </script>
</body>
</html>